# Design Pattern - Factory

La Fabrique (Factory) est un patron de conception de création qui permet de créer des produits sans avoir à préciser leurs classes concrètes.

La fabrique définit une méthode qui doit être utilisée pour créer des objets à la place de l’appel au constructeur (opérateur new). Les sous-classes peuvent redéfinir cette méthode pour modifier la classe des objets qui seront créés.

## Modèle UML

![Alt text](./img/designPattern_Factory.gif) 

## Cas particulier : Fabrique simple

Un exemple d'implémentation, une fabrique de véhicule (voiture, vélo, etc.)

Prenons des classes de véhicules héritant d'une classe mère :

```java
enum etypeVehicule{
    eVoiture,
    eVelo
}

// classe abstraite :
Public abstract class Vehicule {
    public Vehicule(){;}
    Public abstract void rouler();
}

// classes filles :
public class Voiture extends Vehicule {
    public Voiture(){;}
    public void rouler(){
    	System.out.println("je pollue");
    }
}
public class Velo : public Vehicule {
    public Velo();
    public void rouler(){
    	System.out.println("je pollue");
    }
}

``` 

On pourrait imaginer le système suivant :

```java
public class fabriqueSimple {
    public fabriqueSimple(){;}
    Vehicule creerVehicule(etypeVehicule type){
    	if (type == eVoiture)
		return new Voiture;
    	if (type == eVelo)
		return new Velo;
    	return null;
	}
}

``` 
Le problème de cet exemple : 

* On veut éviter le switch/case (série de if dans notre cas) qui peut être dangereuse (ça sent la copier-couiller…)
* On veut éviter de modifier cette classe à chaque nouvel objet.

Ou encore :

```java
public class fabriqueSimple {
    public fabriqueSimple(){}
    
    Voiture creerVoiture(){
    	 return new Voiture;
    }
	
    Velo creerVelo(){
    	 return new Veto;
    }
}

``` 

Ce type fabrique est utilisée pour la construction d'objet avec par exemples des cas particuliers que l'on ne veut pas mettre dans la classe principale.

Et l'on peut imaginer d'autres fabriques, ayant des comportements différents :

```java
public abstract class abstractFabrique {
    public abstractFabrique(){;}
    public abstract Voiture creerVoiture();
    public abstract Voiture creerVelo();
}

public class fabriqueA extends abstractFabrique {
    public fabriqueA(){;}
    public abstract Voiture creerVoiture(){
     //je créé des voiture à essence
     }
    public abstract Voiture creerVelo(){
    //je créé des vélos hollandais
    }
}

public class fabriqueB extends abstractFabrique {
    public fabriqueB(){;}
    public abstract Voiture creerVoiture(){
     //je créé des voiture électrique
     }
    public abstract Voiture creerVelo(){
    //je créé des vélos électrique
    }
}

``` 


## Fabrique "plus complexe"

Afin d’éviter la répétition de code (switch ou if/else), on va instancier :

* une map static permettant d’enregistrer les objets à créer à partir des énumérés
* une fonction Register() permettant de remplir la map 
* la fonction creerVehicule() se base désormais sur cette map.

On peut alors créer tous les objets que l’on souhaite sans avoir besoin de modifier la classe « fabrique ».

## Exercice

En reprenant le modèle de données des Véhicule, implémenter la fabrique "plus complexe".

